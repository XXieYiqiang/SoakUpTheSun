{"ast":null,"code":"import { createPrompt, generatorVideo, queryVideoResult } from '@/api/ai';\n// JavaScript 逻辑保持不变\nexport default {\n  data() {\n    return {\n      startTime: null,\n      taskId: null,\n      labelPosition: 'top',\n      formData: {\n        title: '美女跳舞',\n        userPrompt: '美女跳舞',\n        videoStyle: '写实风格',\n        videoLength: '15'\n      },\n      videoKey: 0,\n      // 用来强制重新渲染视频播放器\n      playerOptions: {\n        techOrder: ['html5'],\n        sources: [{\n          type: 'video/mp4',\n          // src: 'https://vjs.zencdn.net/v/oceans.mp4',  // 视频源\n          // src: 'https://tempfile.aiquickdraw.com/f/aaebe9df5e951608796487abbaebd7a9/4481152c-38db-465e-87ab-ebb45dfe36cc.mp4'\n          src: 'https://tempfile.aiquickdraw.com/r/5407877d-1beb-450f-9f98-d250134c32fa_watermarked.mp4'\n        }],\n        poster: 'https://vjs.zencdn.net/v/oceans.png',\n        // 预览图\n        controls: true,\n        controlBar: {\n          children: ['playToggle', 'volumePanel', 'timeDivider', 'progressControl', 'fullscreenToggle'],\n          align: 'center'\n        }\n      },\n      // 模拟的时间线数据\n      // 更新后的分片信息数据\n      timelineData: [{\n        segmentTitle: '片段 1：未来都市景观',\n        beginTime: '0',\n        // 模拟 API 返回的字符串秒数\n        endTime: '5',\n        // 模拟 API 返回的字符串秒数\n        segmentDescription: '清晨，一架赛博朋克风格的无人机缓缓飞过未来都市的高耸入云的摩天大楼群。城市被浓雾笼罩，霓虹灯尚未熄灭，地面湿润反射着灯光。要求画面有极高的细节分辨率，色彩饱和度高。',\n        segmentKeywords: '无人机, 赛博朋克, 霓虹灯, 摩天大楼',\n        shardingStyle: '超现实写实风格',\n        // 新增字段\n        fragmentedComposition: '大景深航拍全景',\n        // 新增字段\n        fragmentedLightAndShadow: '强对比丁达尔光束',\n        // 新增字段\n        fragmentedCameraMovement: '慢速推拉摇移 (Dolly Zoom)' // 新增字段\n      }, {\n        segmentTitle: '片段 2：街头武者对决',\n        beginTime: '5',\n        // 模拟 API 返回的字符串秒数\n        endTime: '10',\n        // 模拟 API 返回的字符串秒数\n        segmentDescription: '一名身穿铠甲的武者在雨夜的日式街头与机械敌人对峙。武者拔出武士刀，动作干净利落，背景有破碎的全息广告牌。',\n        segmentKeywords: '武士, 战斗, 雨夜, 全息投影, 机械敌人',\n        shardingStyle: '卡通渲染 (Cel Shading)',\n        fragmentedComposition: '中景特写，低角度拍摄',\n        fragmentedLightAndShadow: '高光强调，水面反射光',\n        fragmentedCameraMovement: '高速环绕运镜 (Orbit Shot)'\n      }, {\n        segmentTitle: '片段 3：数据流涌动',\n        beginTime: '10',\n        // 模拟 API 返回的字符串秒数\n        endTime: '15',\n        // 模拟 API 返回的字符串秒数\n        segmentDescription: '一个身着黑客服饰的女子，双手触摸着布满蓝色数据流的墙壁。画面主体清晰，背景虚焦，突出数据流动的动态感。',\n        segmentKeywords: '黑客, 数据流, 蓝色, 动态',\n        shardingStyle: '未来感风格',\n        fragmentedComposition: '特写景别，三分法构图',\n        fragmentedLightAndShadow: '环境光，蓝色背光',\n        fragmentedCameraMovement: '稳定慢速平移 (Tracking Shot)'\n      }]\n    };\n  },\n  methods: {\n    /**\r\n     * 生成视频\r\n     */\n    async generateVideo() {\n      const param = {\n        segmentInfoList: this.timelineData\n      };\n      const respData = await generatorVideo(param);\n      console.log('respData', respData);\n      if (respData.data.code == 200 && respData.data.data) {\n        this.taskId = respData.data.data;\n        console.log('this.taskId =', this.taskId);\n\n        // 启动定时任务，每隔 30 秒查询一次视频状态\n        this.startPollingTask();\n        this.$message({\n          message: '操作成功！视频生成任务已开始！',\n          type: 'success',\n          duration: 3000\n        });\n      } else {\n        this.$message({\n          message: '操作失败，请稍后进行重试！',\n          type: 'error',\n          duration: 3000\n        });\n      }\n    },\n    /**\r\n     * 启动轮询任务\r\n     */\n    startPollingTask() {\n      const that = this;\n      console.log('taskId=begin', that.taskId);\n      // 设置轮询间隔（30秒）\n      this.taskInterval = setInterval(async () => {\n        console.log('taskId=end', that.taskId);\n        const param = {\n          taskId: that.taskId\n        };\n        console.log('param=', param);\n        const respData = await queryVideoResult(param);\n        console.log('[startPollingTask]respData=', respData);\n        if (respData.data.code == 200 && respData.data.data) {\n          console.log('视频url:', respData.data.data);\n\n          // this.playerOptions.sources[0].src = respData.data.data\n\n          this.videoKey += 1; // 改变 key，强制重新渲染视频播放器\n          this.$set(this.playerOptions.sources, 0, {\n            type: 'video/mp4',\n            src: respData.data.data\n          });\n          console.log('图片视频url:', this.playerOptions.sources[0].src);\n          clearInterval(this.taskInterval); // 停止定时任务\n          this.$message({\n            message: '视频生成完成！',\n            type: 'success',\n            duration: 3000\n          });\n        } else {\n          const resState = respData.message;\n          if (resState === \"2\") {\n            // 如果任务失败，停止轮询\n            clearInterval(this.taskInterval);\n            this.$message.error(\"任务生成失败\");\n          } else if (resState === \"3\") {\n            // 如果任务失败，停止轮询\n            clearInterval(this.taskInterval);\n            log.info(\"操作失败，任务创建成功但生成失败\");\n            this.$message.error(\"任务创建成功但生成失败\");\n          } else if (resState === \"-1\") {\n            // 如果任务失败，停止轮询\n            clearInterval(this.taskInterval);\n            log.info(\"操作失败，请稍后重试！\");\n            this.$message.error(\"操作失败，请稍后重试！\");\n          }\n        }\n\n        // 超过10分钟仍没有结果，停止轮询\n        if (!this.startTime) {\n          this.startTime = new Date().getTime();\n        }\n        const currentTime = new Date().getTime();\n        if (currentTime - this.startTime > 10 * 60 * 1000) {\n          // 10分钟\n          clearInterval(this.taskInterval);\n          this.$message({\n            message: '操作失败，视频生成超时，已停止查询结果。',\n            type: 'error',\n            duration: 3000\n          });\n        }\n      }, 1000 * 8);\n    },\n    /**\r\n     * 停止轮询任务\r\n     */\n    stopPollingTask() {\n      if (this.taskInterval) {\n        clearInterval(this.taskInterval);\n      }\n    },\n    /**\r\n     * 保存表单数据到浏览器的 localStorage\r\n     */\n    saveFormData() {\n      const token = this.$store.getters['user/token'];\n      localStorage.setItem('formData=' + token, JSON.stringify(this.formData));\n      this.$message({\n        message: '数据已保存！',\n        type: 'success',\n        duration: 3000\n      });\n    },\n    /**\r\n     * 加载保存的表单数据\r\n     */\n    loadFormData() {\n      // 从 localStorage 获取保存的表单数据\n      const token = this.$store.getters['user/token'];\n      const savedData = localStorage.getItem('formData=' + token);\n      if (savedData) {\n        this.formData = JSON.parse(savedData); // 解析并加载数据\n      }\n    },\n    /**\r\n     * 清空内容\r\n     */\n    clearData() {\n      this.formData = {\n        title: '',\n        userPrompt: '',\n        videoStyle: '',\n        videoLength: ''\n      };\n      const token = this.$store.getters['user/token'];\n      localStorage.removeItem('formData=' + token);\n    },\n    /**\r\n     * 获取AI分片提示词\r\n     */\n    async getVideoPrompt() {\n      console.log('getVideoPrompt');\n      let param = {\n        ...this.formData\n      };\n      const resData = await createPrompt(param);\n      console.log('resData=', resData);\n      if (resData.data.code == 200 && resData.data.data && resData.data.data.length > 0) {\n        this.timelineData = resData.data.data;\n        this.$message({\n          message: '提示词已生成，分片信息已更新！',\n          type: 'success',\n          duration: 3000\n        });\n      } else {\n        this.$message({\n          message: '提示词生成失败或数据为空。',\n          type: 'error',\n          duration: 3000\n        });\n      }\n    },\n    /**\r\n    * 复制指定分片的数据到剪贴板\r\n    * @param {Object} item - 分片数据对象\r\n    */\n    copySegmentData(item) {\n      // 1. 格式化文本\n      const copyText = [`分片标题：${item.segmentTitle}`, `详细的画面描述：${item.segmentDescription}`, `关键字：${item.segmentKeywords}`, `风格：${item.shardingStyle}`, `构图描述：${item.fragmentedComposition}`, `光影描述：${item.fragmentedLightAndShadow}`, `运镜描述：${item.fragmentedCameraMovement}`].join('\\n'); // 使用换行符分隔\n\n      // 2. 复制到剪贴板\n      if (navigator.clipboard) {\n        navigator.clipboard.writeText(copyText).then(() => {\n          // 3. 复制成功提示\n          this.$message({\n            message: '分片信息已成功复制到剪贴板！',\n            type: 'success',\n            duration: 2000\n          });\n        }).catch(err => {\n          // 复制失败提示\n          this.$message({\n            message: `复制失败：${err}`,\n            type: 'error',\n            duration: 3000\n          });\n        });\n      } else {\n        // 兼容性提示（旧版浏览器）\n        this.$message({\n          message: '您的浏览器不支持 navigator.clipboard，请手动复制。',\n          type: 'warning',\n          duration: 4000\n        });\n      }\n    },\n    /**\r\n     * 将秒数转换为 MM:SS 格式\r\n     * @param {string | number} totalSeconds - 总秒数\r\n     * @returns {string} 格式化后的时间字符串 (MM:SS)\r\n    */\n    formatSecondsToTime(totalSeconds) {\n      const seconds = parseInt(totalSeconds);\n      if (isNaN(seconds) || seconds < 0) {\n        return '00:00';\n      }\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = seconds % 60;\n\n      // 确保是两位数\n      const formattedMinutes = String(minutes).padStart(2, '0');\n      const formattedSeconds = String(remainingSeconds).padStart(2, '0');\n      return `${formattedMinutes}:${formattedSeconds}`;\n    },\n    /**\r\n     * 根据分片的起始和结束时间，生成时间戳字符串\r\n     * @param {Object} item - 分片数据对象 (包含 beginTime 和 endTime)\r\n     * @returns {string} 格式化的时间范围字符串 (MM:SS - MM:SS)\r\n     */\n    getSegmentTimestamp(item) {\n      const startTime = this.formatSecondsToTime(item.beginTime || 0);\n      const endTime = this.formatSecondsToTime(item.endTime || 0);\n      return `${startTime} - ${endTime}`;\n    }\n  },\n  mounted() {\n    this.loadFormData();\n  },\n  beforeDestroy() {\n    // 在组件销毁时清除定时任务，避免内存泄漏\n    this.stopPollingTask();\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}