{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nrequire(\"core-js/modules/es.iterator.constructor.js\");\nrequire(\"core-js/modules/es.iterator.for-each.js\");\nvar _default = exports.default = {\n  name: \"SFURoom\",\n  data() {\n    return {\n      // 配置\n      wsUrl: \"ws://localhost:8080/room/join\",\n      // 请根据实际后端地址修改\n      roomID: \"room1\",\n      uid: \"user_\" + Math.floor(Math.random() * 1000),\n      // 状态\n      joined: false,\n      loading: false,\n      logs: [],\n      // WebRTC 对象\n      ws: null,\n      localStream: null,\n      upPC: null,\n      // 推流 PC\n      downPC: null,\n      // 拉流 PC (单 PC 接收所有流)\n\n      // 远端流映射表 { uid: MediaStream }\n      remoteStreams: {}\n    };\n  },\n  methods: {\n    log(msg) {\n      const time = new Date().toLocaleTimeString();\n      this.logs.unshift(`[${time}] ${msg}`);\n      console.log(`[SFU] ${msg}`);\n    },\n    async joinRoom() {\n      if (!this.roomID || !this.uid) return alert(\"请输入房间号和UID\");\n      this.loading = true;\n      try {\n        // 1. 获取本地媒体流\n        this.localStream = await navigator.mediaDevices.getUserMedia({\n          video: true,\n          audio: true\n        });\n        this.$refs.localVideo.srcObject = this.localStream;\n        this.log(\"获取本地媒体流成功\");\n\n        // 2. 连接 WebSocket\n        this.connectWebSocket();\n      } catch (e) {\n        this.log(\"启动失败: \" + e.message);\n        this.loading = false;\n      }\n    },\n    connectWebSocket() {\n      // 构建 URL query 参数\n      const url = `${this.wsUrl}?uid=${this.uid}&roomID=${this.roomID}`;\n      this.ws = new WebSocket(url);\n      this.ws.onopen = () => {\n        this.log(\"WebSocket 已连接\");\n        this.joined = true;\n        this.loading = false;\n        // WS 连接成功后，立即启动推流流程\n        this.createUpstream();\n      };\n      this.ws.onmessage = event => {\n        this.handleSignal(JSON.parse(event.data));\n      };\n      this.ws.onerror = e => this.log(\"WS 错误: \" + e);\n      this.ws.onclose = () => {\n        this.log(\"WS 已断开\");\n        this.leaveRoom(false); // 清理资源\n      };\n    },\n    // 处理后端发来的信令\n    async handleSignal(msg) {\n      const {\n        event,\n        data\n      } = msg;\n      switch (event) {\n        // 收到后端的 Answer (响应我们的 up_offer)\n        case \"up_answer\":\n          await this.upPC.setRemoteDescription(new RTCSessionDescription({\n            type: 'answer',\n            sdp: data.sdp\n          }));\n          this.log(\"设置 UpPC Remote Description 成功\");\n          break;\n\n        // 收到 UpPC 的 ICE Candidate\n        case \"up_candidate\":\n          if (this.upPC) {\n            await this.upPC.addIceCandidate(data.candidate);\n          }\n          break;\n\n        // 收到后端发来的 Offer (用于订阅房间内的流)\n        case \"down_offer\":\n          this.handleDownOffer(data);\n          break;\n\n        // 收到 DownPC 的 ICE Candidate\n        case \"down_candidate\":\n          if (this.downPC) {\n            await this.downPC.addIceCandidate(data.candidate);\n          }\n          break;\n\n        // 用户离开 (后端 cleanupUser 触发)\n        case \"user_leave\":\n          this.removeRemoteUser(data.uid);\n          break;\n\n        // 用户停止推流\n        case \"unpublish_stream\":\n          // data.publisherId 对应后端的 payload key\n          this.removeRemoteUser(data.publisherId);\n          break;\n      }\n    },\n    // ===========================\n    // 推流逻辑 (Upstream)\n    // ===========================\n    async createUpstream() {\n      this.log(\"开始创建推流连接 (UpPC)...\");\n      const config = {\n        iceServers: [{\n          urls: \"stun:stun.l.google.com:19302\"\n        }]\n      };\n      this.upPC = new RTCPeerConnection(config);\n\n      // 1. 添加本地轨道\n      this.localStream.getTracks().forEach(track => {\n        this.upPC.addTrack(track, this.localStream);\n      });\n\n      // 2. 处理 ICE Candidate\n      this.upPC.onicecandidate = event => {\n        if (event.candidate) {\n          this.sendSignal(\"up_candidate\", {\n            candidate: event.candidate\n          });\n        }\n      };\n\n      // 3. 创建 Offer\n      const offer = await this.upPC.createOffer();\n      await this.upPC.setLocalDescription(offer);\n\n      // 4. 发送 Offer 给后端\n      this.sendSignal(\"up_offer\", {\n        uid: this.uid,\n        sdp: offer.sdp\n      });\n    },\n    // ===========================\n    // 拉流逻辑 (Downstream)\n    // ===========================\n    async handleDownOffer(data) {\n      this.log(`收到订阅请求 (DownOffer)，来自: ${data.from || 'Server'}`);\n\n      // 如果 DownPC 不存在，则初始化 (通常只初始化一次)\n      if (!this.downPC) {\n        this.createDownPC();\n      }\n\n      // 1. 设置 Remote Description (Server Offer)\n      // 注意：如果此时状态不对，可能需要根据 signalingState 做判断\n      if (this.downPC.signalingState !== \"stable\" && this.downPC.signalingState !== \"have-local-offer\") {\n        // 简单的冲突处理，实际情况可能需要队列\n        // 但 SFU 后端现在的逻辑应该能保证顺序\n      }\n      await this.downPC.setRemoteDescription(new RTCSessionDescription({\n        type: 'offer',\n        sdp: data.sdp\n      }));\n\n      // 2. 创建 Answer\n      const answer = await this.downPC.createAnswer();\n      await this.downPC.setLocalDescription(answer);\n\n      // 3. 发送 Answer 回给后端\n      this.sendSignal(\"down_answer\", {\n        sdp: answer.sdp\n      });\n    },\n    createDownPC() {\n      const config = {\n        iceServers: [{\n          urls: \"stun:stun.l.google.com:19302\"\n        }]\n      };\n      this.downPC = new RTCPeerConnection(config);\n      this.downPC.onicecandidate = event => {\n        if (event.candidate) {\n          this.sendSignal(\"down_candidate\", {\n            candidate: event.candidate\n          });\n        }\n      };\n\n      // 核心：处理远端流的到来\n      this.downPC.ontrack = event => {\n        const stream = event.streams[0];\n        // 后端代码：webrtc.NewTrackLocalStaticRTP(..., ..., user.UID)\n        // 所以 stream.id 应该是发布者的 UID\n        const remoteUid = stream.id;\n        this.log(`收到远端流 Track: ${event.track.kind}, 用户: ${remoteUid}`);\n\n        // Vue 2 响应式添加属性\n        // 如果该用户的流已经存在，不需要重新赋值，否则会导致闪烁\n        if (!this.remoteStreams[remoteUid]) {\n          this.$set(this.remoteStreams, remoteUid, stream);\n        }\n      };\n    },\n    // 移除远端用户\n    removeRemoteUser(targetUid) {\n      if (this.remoteStreams[targetUid]) {\n        this.log(`用户 ${targetUid} 已离开/停止推流，移除画面`);\n        this.$delete(this.remoteStreams, targetUid);\n      }\n    },\n    // 发送 WebSocket 消息帮助函数\n    sendSignal(event, data) {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(JSON.stringify({\n          event: event,\n          data: data // sonic/json.RawMessage 期望这里是对象或 JSON\n        }));\n      }\n    },\n    leaveRoom(closeWs = true) {\n      this.joined = false;\n      this.remoteStreams = {};\n      this.logs = [];\n\n      // 关闭 PeerConnections\n      if (this.upPC) {\n        this.upPC.close();\n        this.upPC = null;\n      }\n      if (this.downPC) {\n        this.downPC.close();\n        this.downPC = null;\n      }\n\n      // 停止本地流\n      if (this.localStream) {\n        this.localStream.getTracks().forEach(t => t.stop());\n        this.localStream = null;\n      }\n\n      // 关闭 WebSocket\n      if (closeWs && this.ws) {\n        this.ws.close();\n        this.ws = null;\n      }\n    }\n  },\n  beforeDestroy() {\n    this.leaveRoom();\n  }\n};","map":{"version":3,"names":["name","data","wsUrl","roomID","uid","Math","floor","random","joined","loading","logs","ws","localStream","upPC","downPC","remoteStreams","methods","log","msg","time","Date","toLocaleTimeString","unshift","console","joinRoom","alert","navigator","mediaDevices","getUserMedia","video","audio","$refs","localVideo","srcObject","connectWebSocket","e","message","url","WebSocket","onopen","createUpstream","onmessage","event","handleSignal","JSON","parse","onerror","onclose","leaveRoom","setRemoteDescription","RTCSessionDescription","type","sdp","addIceCandidate","candidate","handleDownOffer","removeRemoteUser","publisherId","config","iceServers","urls","RTCPeerConnection","getTracks","forEach","track","addTrack","onicecandidate","sendSignal","offer","createOffer","setLocalDescription","from","createDownPC","signalingState","answer","createAnswer","ontrack","stream","streams","remoteUid","id","kind","$set","targetUid","$delete","readyState","OPEN","send","stringify","closeWs","close","t","stop","beforeDestroy"],"sources":["src/views/utils/test2.vue"],"sourcesContent":["<template>\r\n  <div class=\"sfu-room\">\r\n    <div class=\"controls\">\r\n      <h2>SFU 视频会议 (Vue 2)</h2>\r\n      <div v-if=\"!joined\" class=\"login-form\">\r\n        <input v-model=\"roomID\" placeholder=\"房间号\" />\r\n        <input v-model=\"uid\" placeholder=\"用户UID\" />\r\n        <button @click=\"joinRoom\" :disabled=\"loading\">进入房间</button>\r\n      </div>\r\n      <div v-else class=\"actions\">\r\n        <span>房间: {{ roomID }} | 用户: {{ uid }}</span>\r\n        <button class=\"btn-leave\" @click=\"leaveRoom\">离开房间</button>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"video-grid\">\r\n      <div class=\"video-card local\">\r\n        <video ref=\"localVideo\" autoplay playsinline muted></video>\r\n        <div class=\"label\">我 ({{ uid }})</div>\r\n      </div>\r\n\r\n      <div \r\n        v-for=\"(stream, remoteUid) in remoteStreams\" \r\n        :key=\"remoteUid\" \r\n        class=\"video-card remote\"\r\n      >\r\n        <video :src-object.prop=\"stream\" autoplay playsinline></video>\r\n        <div class=\"label\">用户: {{ remoteUid }}</div>\r\n      </div>\r\n    </div>\r\n\r\n    <div class=\"logs\">\r\n      <p v-for=\"(log, i) in logs\" :key=\"i\">{{ log }}</p>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n  name: \"SFURoom\",\r\n  data() {\r\n    return {\r\n      // 配置\r\n      wsUrl: \"ws://localhost:8080/room/join\", // 请根据实际后端地址修改\r\n      roomID: \"room1\",\r\n      uid: \"user_\" + Math.floor(Math.random() * 1000),\r\n      \r\n      // 状态\r\n      joined: false,\r\n      loading: false,\r\n      logs: [],\r\n\r\n      // WebRTC 对象\r\n      ws: null,\r\n      localStream: null,\r\n      upPC: null,   // 推流 PC\r\n      downPC: null, // 拉流 PC (单 PC 接收所有流)\r\n      \r\n      // 远端流映射表 { uid: MediaStream }\r\n      remoteStreams: {} \r\n    };\r\n  },\r\n  methods: {\r\n    log(msg) {\r\n      const time = new Date().toLocaleTimeString();\r\n      this.logs.unshift(`[${time}] ${msg}`);\r\n      console.log(`[SFU] ${msg}`);\r\n    },\r\n\r\n    async joinRoom() {\r\n      if (!this.roomID || !this.uid) return alert(\"请输入房间号和UID\");\r\n      this.loading = true;\r\n\r\n      try {\r\n        // 1. 获取本地媒体流\r\n        this.localStream = await navigator.mediaDevices.getUserMedia({\r\n          video: true,\r\n          audio: true\r\n        });\r\n        this.$refs.localVideo.srcObject = this.localStream;\r\n        this.log(\"获取本地媒体流成功\");\r\n\r\n        // 2. 连接 WebSocket\r\n        this.connectWebSocket();\r\n      } catch (e) {\r\n        this.log(\"启动失败: \" + e.message);\r\n        this.loading = false;\r\n      }\r\n    },\r\n\r\n    connectWebSocket() {\r\n      // 构建 URL query 参数\r\n      const url = `${this.wsUrl}?uid=${this.uid}&roomID=${this.roomID}`;\r\n      this.ws = new WebSocket(url);\r\n\r\n      this.ws.onopen = () => {\r\n        this.log(\"WebSocket 已连接\");\r\n        this.joined = true;\r\n        this.loading = false;\r\n        // WS 连接成功后，立即启动推流流程\r\n        this.createUpstream();\r\n      };\r\n\r\n      this.ws.onmessage = (event) => {\r\n        this.handleSignal(JSON.parse(event.data));\r\n      };\r\n\r\n      this.ws.onerror = (e) => this.log(\"WS 错误: \" + e);\r\n      this.ws.onclose = () => {\r\n        this.log(\"WS 已断开\");\r\n        this.leaveRoom(false); // 清理资源\r\n      };\r\n    },\r\n\r\n    // 处理后端发来的信令\r\n    async handleSignal(msg) {\r\n      const { event, data } = msg;\r\n\r\n      switch (event) {\r\n        // 收到后端的 Answer (响应我们的 up_offer)\r\n        case \"up_answer\":\r\n          await this.upPC.setRemoteDescription(new RTCSessionDescription({\r\n            type: 'answer',\r\n            sdp: data.sdp\r\n          }));\r\n          this.log(\"设置 UpPC Remote Description 成功\");\r\n          break;\r\n\r\n        // 收到 UpPC 的 ICE Candidate\r\n        case \"up_candidate\":\r\n          if (this.upPC) {\r\n            await this.upPC.addIceCandidate(data.candidate);\r\n          }\r\n          break;\r\n\r\n        // 收到后端发来的 Offer (用于订阅房间内的流)\r\n        case \"down_offer\":\r\n          this.handleDownOffer(data);\r\n          break;\r\n\r\n        // 收到 DownPC 的 ICE Candidate\r\n        case \"down_candidate\":\r\n          if (this.downPC) {\r\n            await this.downPC.addIceCandidate(data.candidate);\r\n          }\r\n          break;\r\n\r\n        // 用户离开 (后端 cleanupUser 触发)\r\n        case \"user_leave\":\r\n          this.removeRemoteUser(data.uid);\r\n          break;\r\n\r\n        // 用户停止推流\r\n        case \"unpublish_stream\":\r\n          // data.publisherId 对应后端的 payload key\r\n          this.removeRemoteUser(data.publisherId);\r\n          break;\r\n      }\r\n    },\r\n\r\n    // ===========================\r\n    // 推流逻辑 (Upstream)\r\n    // ===========================\r\n    async createUpstream() {\r\n      this.log(\"开始创建推流连接 (UpPC)...\");\r\n      const config = {\r\n        iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }]\r\n      };\r\n      \r\n      this.upPC = new RTCPeerConnection(config);\r\n\r\n      // 1. 添加本地轨道\r\n      this.localStream.getTracks().forEach(track => {\r\n        this.upPC.addTrack(track, this.localStream);\r\n      });\r\n\r\n      // 2. 处理 ICE Candidate\r\n      this.upPC.onicecandidate = (event) => {\r\n        if (event.candidate) {\r\n          this.sendSignal(\"up_candidate\", { candidate: event.candidate });\r\n        }\r\n      };\r\n\r\n      // 3. 创建 Offer\r\n      const offer = await this.upPC.createOffer();\r\n      await this.upPC.setLocalDescription(offer);\r\n\r\n      // 4. 发送 Offer 给后端\r\n      this.sendSignal(\"up_offer\", {\r\n        uid: this.uid,\r\n        sdp: offer.sdp\r\n      });\r\n    },\r\n\r\n    // ===========================\r\n    // 拉流逻辑 (Downstream)\r\n    // ===========================\r\n    async handleDownOffer(data) {\r\n      this.log(`收到订阅请求 (DownOffer)，来自: ${data.from || 'Server'}`);\r\n\r\n      // 如果 DownPC 不存在，则初始化 (通常只初始化一次)\r\n      if (!this.downPC) {\r\n        this.createDownPC();\r\n      }\r\n\r\n      // 1. 设置 Remote Description (Server Offer)\r\n      // 注意：如果此时状态不对，可能需要根据 signalingState 做判断\r\n      if (this.downPC.signalingState !== \"stable\" && this.downPC.signalingState !== \"have-local-offer\") {\r\n         // 简单的冲突处理，实际情况可能需要队列\r\n         // 但 SFU 后端现在的逻辑应该能保证顺序\r\n      }\r\n\r\n      await this.downPC.setRemoteDescription(new RTCSessionDescription({\r\n        type: 'offer',\r\n        sdp: data.sdp\r\n      }));\r\n\r\n      // 2. 创建 Answer\r\n      const answer = await this.downPC.createAnswer();\r\n      await this.downPC.setLocalDescription(answer);\r\n\r\n      // 3. 发送 Answer 回给后端\r\n      this.sendSignal(\"down_answer\", { sdp: answer.sdp });\r\n    },\r\n\r\n    createDownPC() {\r\n      const config = {\r\n        iceServers: [{ urls: \"stun:stun.l.google.com:19302\" }]\r\n      };\r\n      this.downPC = new RTCPeerConnection(config);\r\n\r\n      this.downPC.onicecandidate = (event) => {\r\n        if (event.candidate) {\r\n          this.sendSignal(\"down_candidate\", { candidate: event.candidate });\r\n        }\r\n      };\r\n\r\n      // 核心：处理远端流的到来\r\n      this.downPC.ontrack = (event) => {\r\n        const stream = event.streams[0];\r\n        // 后端代码：webrtc.NewTrackLocalStaticRTP(..., ..., user.UID)\r\n        // 所以 stream.id 应该是发布者的 UID\r\n        const remoteUid = stream.id; \r\n\r\n        this.log(`收到远端流 Track: ${event.track.kind}, 用户: ${remoteUid}`);\r\n\r\n        // Vue 2 响应式添加属性\r\n        // 如果该用户的流已经存在，不需要重新赋值，否则会导致闪烁\r\n        if (!this.remoteStreams[remoteUid]) {\r\n           this.$set(this.remoteStreams, remoteUid, stream);\r\n        }\r\n      };\r\n    },\r\n\r\n    // 移除远端用户\r\n    removeRemoteUser(targetUid) {\r\n      if (this.remoteStreams[targetUid]) {\r\n        this.log(`用户 ${targetUid} 已离开/停止推流，移除画面`);\r\n        this.$delete(this.remoteStreams, targetUid);\r\n      }\r\n    },\r\n\r\n    // 发送 WebSocket 消息帮助函数\r\n    sendSignal(event, data) {\r\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\r\n        this.ws.send(JSON.stringify({\r\n          event: event,\r\n          data: data // sonic/json.RawMessage 期望这里是对象或 JSON\r\n        }));\r\n      }\r\n    },\r\n\r\n    leaveRoom(closeWs = true) {\r\n      this.joined = false;\r\n      this.remoteStreams = {};\r\n      this.logs = [];\r\n\r\n      // 关闭 PeerConnections\r\n      if (this.upPC) {\r\n        this.upPC.close();\r\n        this.upPC = null;\r\n      }\r\n      if (this.downPC) {\r\n        this.downPC.close();\r\n        this.downPC = null;\r\n      }\r\n\r\n      // 停止本地流\r\n      if (this.localStream) {\r\n        this.localStream.getTracks().forEach(t => t.stop());\r\n        this.localStream = null;\r\n      }\r\n\r\n      // 关闭 WebSocket\r\n      if (closeWs && this.ws) {\r\n        this.ws.close();\r\n        this.ws = null;\r\n      }\r\n    }\r\n  },\r\n  beforeDestroy() {\r\n    this.leaveRoom();\r\n  }\r\n};\r\n</script>\r\n\r\n<style scoped>\r\n.sfu-room {\r\n  font-family: Arial, sans-serif;\r\n  padding: 20px;\r\n  background: #f0f2f5;\r\n  min-height: 100vh;\r\n}\r\n\r\n.controls {\r\n  margin-bottom: 20px;\r\n  background: white;\r\n  padding: 15px;\r\n  border-radius: 8px;\r\n  box-shadow: 0 2px 4px rgba(0,0,0,0.1);\r\n}\r\n\r\n.login-form input {\r\n  padding: 8px;\r\n  margin-right: 10px;\r\n  border: 1px solid #ddd;\r\n  border-radius: 4px;\r\n}\r\n\r\nbutton {\r\n  padding: 8px 16px;\r\n  background-color: #409eff;\r\n  color: white;\r\n  border: none;\r\n  border-radius: 4px;\r\n  cursor: pointer;\r\n}\r\n\r\nbutton:disabled {\r\n  background-color: #a0cfff;\r\n}\r\n\r\n.btn-leave {\r\n  background-color: #f56c6c;\r\n  margin-left: 10px;\r\n}\r\n\r\n/* 视频网格布局 */\r\n.video-grid {\r\n  display: grid;\r\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\r\n  gap: 20px;\r\n}\r\n\r\n.video-card {\r\n  position: relative;\r\n  background: #000;\r\n  border-radius: 8px;\r\n  overflow: hidden;\r\n  aspect-ratio: 16/9;\r\n  box-shadow: 0 4px 6px rgba(0,0,0,0.2);\r\n}\r\n\r\n.video-card video {\r\n  width: 100%;\r\n  height: 100%;\r\n  object-fit: cover;\r\n}\r\n\r\n.video-card.local video {\r\n  transform: scaleX(-1); /* 镜像本地视频 */\r\n}\r\n\r\n.label {\r\n  position: absolute;\r\n  bottom: 10px;\r\n  left: 10px;\r\n  background: rgba(0, 0, 0, 0.6);\r\n  color: white;\r\n  padding: 4px 8px;\r\n  border-radius: 4px;\r\n  font-size: 12px;\r\n}\r\n\r\n.logs {\r\n  margin-top: 30px;\r\n  background: #333;\r\n  color: #0f0;\r\n  padding: 10px;\r\n  height: 150px;\r\n  overflow-y: auto;\r\n  font-family: monospace;\r\n  font-size: 12px;\r\n  border-radius: 4px;\r\n}\r\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}