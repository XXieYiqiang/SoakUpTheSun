{"ast":null,"code":"import SparkMD5 from 'spark-md5';\nexport default {\n  name: 'FileUploader',\n  data() {\n    return {\n      options: {\n        target: '/api/filetransfer/uploadfile',\n        chunkSize: 1024 * 1024,\n        fileParameterName: 'file',\n        maxChunkRetries: 3,\n        testChunks: true,\n        headers: {\n          token: '123'\n        },\n        checkChunkUploadedByResponse: (chunk, message) => {\n          try {\n            const data = JSON.parse(message).data || {};\n            if (data.skipUpload) return true;\n            return (data.uploaded || []).includes(chunk.offset + 1);\n          } catch {\n            return false;\n          }\n        },\n        query() {}\n      },\n      attrs: {\n        accept: '*'\n      }\n    };\n  },\n  computed: {\n    uploaderInstance() {\n      return this.$refs.uploader.uploader;\n    }\n  },\n  methods: {\n    handleFilesAdded(files) {\n      if (!files || !files.length) return;\n      this.computeMD5(files[0]); // 只支持单文件上传\n    },\n    computeMD5(file) {\n      const reader = new FileReader();\n      const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\n      const chunkSize = 1 * 1024 * 1024;\n      const chunks = Math.ceil(file.size / chunkSize);\n      let currentChunk = 0;\n      const spark = new SparkMD5.ArrayBuffer();\n      file.pause();\n      reader.onload = e => {\n        spark.append(e.target.result);\n        currentChunk++;\n        if (currentChunk < chunks) {\n          loadNext();\n        } else {\n          const md5 = spark.end();\n          this.afterMD5(md5, file);\n        }\n      };\n      reader.onerror = () => {\n        this.$emit('error', '读取文件失败');\n        file.cancel();\n      };\n      const loadNext = () => {\n        const start = currentChunk * chunkSize;\n        const end = Math.min(start + chunkSize, file.size);\n        reader.readAsArrayBuffer(blobSlice.call(file.file, start, end));\n      };\n      loadNext();\n    },\n    afterMD5(md5, file) {\n      file.uniqueIdentifier = md5;\n      file.resume();\n    },\n    handleSuccess(rootFile, file, response) {\n      try {\n        const res = JSON.parse(response);\n        if (res.code === 200 && res.data.uploaded.at(-1) === res.data.uploaded.length) {\n          this.$emit('success', {\n            fileName: file.name,\n            fileSize: file.size,\n            response: res\n          });\n        } else {\n          this.$emit('error', res.message || '上传异常');\n        }\n      } catch (e) {\n        this.$emit('error', '解析响应失败');\n      }\n    },\n    handleError(rootFile, file, response) {\n      this.$emit('error', response || '上传失败');\n    },\n    cancelUpload() {\n      this.uploaderInstance.cancel();\n      this.$emit('cancel');\n    }\n  }\n};","map":{"version":3,"names":["SparkMD5","name","data","options","target","chunkSize","fileParameterName","maxChunkRetries","testChunks","headers","token","checkChunkUploadedByResponse","chunk","message","JSON","parse","skipUpload","uploaded","includes","offset","query","attrs","accept","computed","uploaderInstance","$refs","uploader","methods","handleFilesAdded","files","length","computeMD5","file","reader","FileReader","blobSlice","File","prototype","slice","mozSlice","webkitSlice","chunks","Math","ceil","size","currentChunk","spark","ArrayBuffer","pause","onload","e","append","result","loadNext","md5","end","afterMD5","onerror","$emit","cancel","start","min","readAsArrayBuffer","call","uniqueIdentifier","resume","handleSuccess","rootFile","response","res","code","at","fileName","fileSize","handleError","cancelUpload"],"sources":["src/components/FileUploader.vue"],"sourcesContent":["<template>\r\n  <div>\r\n    <uploader ref=\"uploader\" :options=\"options\" @file-added=\"handleFilesAdded\"\r\n              @file-success=\"handleSuccess\" @file-error=\"handleError\" :autoStart=\"false\">\r\n      <uploader-btn :attrs=\"attrs\" ref=\"uploadBtn\">\r\n        <el-button type=\"primary\" icon=\"el-icon-upload\">上传文件</el-button>\r\n      </uploader-btn>\r\n    </uploader>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport SparkMD5 from 'spark-md5';\r\n\r\nexport default {\r\n  name: 'FileUploader',\r\n  data() {\r\n    return {\r\n      options: {\r\n        target: '/api/filetransfer/uploadfile',\r\n        chunkSize: 1024 * 1024,\r\n        fileParameterName: 'file',\r\n        maxChunkRetries: 3,\r\n        testChunks: true,\r\n        headers: { token: '123' },\r\n        checkChunkUploadedByResponse: (chunk, message) => {\r\n          try {\r\n            const data = JSON.parse(message).data || {};\r\n            if (data.skipUpload) return true;\r\n            return (data.uploaded || []).includes(chunk.offset + 1);\r\n          } catch {\r\n            return false;\r\n          }\r\n        },\r\n        query() {}\r\n      },\r\n      attrs: {\r\n        accept: '*'\r\n      }\r\n    };\r\n  },\r\n  computed: {\r\n    uploaderInstance() {\r\n      return this.$refs.uploader.uploader;\r\n    }\r\n  },\r\n  methods: {\r\n    handleFilesAdded(files) {\r\n      if (!files || !files.length) return;\r\n      this.computeMD5(files[0]); // 只支持单文件上传\r\n    },\r\n    computeMD5(file) {\r\n      const reader = new FileReader();\r\n      const blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;\r\n      const chunkSize = 1 * 1024 * 1024;\r\n      const chunks = Math.ceil(file.size / chunkSize);\r\n      let currentChunk = 0;\r\n      const spark = new SparkMD5.ArrayBuffer();\r\n\r\n      file.pause();\r\n\r\n      reader.onload = (e) => {\r\n        spark.append(e.target.result);\r\n        currentChunk++;\r\n        if (currentChunk < chunks) {\r\n          loadNext();\r\n        } else {\r\n          const md5 = spark.end();\r\n          this.afterMD5(md5, file);\r\n        }\r\n      };\r\n\r\n      reader.onerror = () => {\r\n        this.$emit('error', '读取文件失败');\r\n        file.cancel();\r\n      };\r\n\r\n      const loadNext = () => {\r\n        const start = currentChunk * chunkSize;\r\n        const end = Math.min(start + chunkSize, file.size);\r\n        reader.readAsArrayBuffer(blobSlice.call(file.file, start, end));\r\n      };\r\n\r\n      loadNext();\r\n    },\r\n    afterMD5(md5, file) {\r\n      file.uniqueIdentifier = md5;\r\n      file.resume();\r\n    },\r\n    handleSuccess(rootFile, file, response) {\r\n      try {\r\n        const res = JSON.parse(response);\r\n        if (res.code === 200 && res.data.uploaded.at(-1) === res.data.uploaded.length) {\r\n          this.$emit('success', {\r\n            fileName: file.name,\r\n            fileSize: file.size,\r\n            response: res\r\n          });\r\n        } else {\r\n          this.$emit('error', res.message || '上传异常');\r\n        }\r\n      } catch (e) {\r\n        this.$emit('error', '解析响应失败');\r\n      }\r\n    },\r\n    handleError(rootFile, file, response) {\r\n      this.$emit('error', response || '上传失败');\r\n    },\r\n    cancelUpload() {\r\n      this.uploaderInstance.cancel();\r\n      this.$emit('cancel');\r\n    }\r\n  }\r\n};\r\n</script>\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}