<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC SFU 视频会议测试</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f4f4f4; }
        #controls { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; width: 90%; max-width: 700px; background-color: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 8px; }
        #videos { display: flex; flex-wrap: wrap; justify-content: center; gap: 20px; width: 90%; max-width: 1200px; }
        .video-container { text-align: center; background-color: #333; padding: 5px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        video { width: 320px; height: 240px; background: #000; border: 1px solid #000; border-radius: 4px; }
        #status { font-weight: bold; color: #007bff; margin-top: 10px; }
    </style>
</head>
<body>

    <h1>WebRTC SFU 视频会议测试</h1>
    
    <div id="controls">
        <label for="roomIdInput">房间号 (Room ID):</label>
        <input type="text" id="roomIdInput" value="test-room-1" />
        <button onclick="joinRoom()">加入房间 / 重新连接</button>
        <p id="status">状态: 未连接</p>
        <p>您的服务器分配 UID: <span id="localUidDisplay">---</span></p>
    </div>

    <div id="videos">
        <div class="video-container">
            <h2>本地视频 (Local)</h2>
            <video id="localVideo" autoplay muted playsinline></video>
        </div>
    </div>

    <script>
        // ------------------- 配置 -------------------
        // !!! 替换为您的 SFU 服务器地址 (使用 wss:// 或 ws://) !!!
        const WS_URL = 'ws://127.0.0.1:10014/room/join?roomID=';
        const CONFIG = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
            ],
        };
        
        // ------------------- 全局状态 -------------------
        let ws;
        let localStream;
        let upPC; // 上行 PeerConnection (Publisher)
        let downPC; // 下行 PeerConnection (Subscriber)
        let localUID = null; // **服务器分配的** 客户端唯一 ID
        let remoteVideoElements = {}; // 存储远端视频元素的映射

        const statusElement = document.getElementById('status');
        const localUidDisplay = document.getElementById('localUidDisplay');

        function updateStatus(message) {
            statusElement.textContent = '状态: ' + message;
            console.log('状态:', message);
        }

        // ------------------- WebSocket 信令 -------------------

        function setupWebSocket(roomID) {
            if (ws) {
                ws.close();
            }
            
            // 客户端不自行生成 UID，等待服务器分配
            localUID = null; 
            localUidDisplay.textContent = '---';

            const url = WS_URL + roomID;
            ws = new WebSocket(url);

            ws.onopen = async () => {
                // 等待服务器发送 server_ready 消息以获取 UID
                updateStatus('WebSocket 连接成功。等待服务器分配 UID...');
            };

            ws.onmessage = async (event) => {
                const signal = JSON.parse(event.data);
                const { event: signalEvent, data } = signal;

                switch (signalEvent) {
                    case 'server_ready':
                        // 服务器分配的 UID
                        localUID = data.uid;
                        localUidDisplay.textContent = localUID;
                        updateStatus(`服务器连接就绪，UID: ${localUID}。正在获取媒体并发送 Offer...`);
                        
                        // 收到 UID 后，开始媒体和 WebRTC 协商
                        try {
                            await startLocalMedia();
                            await createUpPC(localStream);
                            await ensureDownPC(); // 确保 DownPC 存在以接收所有订阅
                        } catch (e) {
                            console.error("初始化失败:", e);
                            updateStatus("初始化失败，请检查媒体权限或控制台错误");
                        }
                        break;
                        
                    case 'up_candidate':
                        if (upPC && data.candidate) {
                            upPC.addIceCandidate(data.candidate).catch(e => console.error("Error adding up_candidate:", e));
                        }
                        break;
                    case 'up_answer':
                        if (upPC && data.sdp) {
                            await upPC.setRemoteDescription({ type: 'answer', sdp: data.sdp });
                            updateStatus('已完成上行协商 (Publisher)。');
                        }
                        break;
                    case 'down_offer':
                        // 服务器给客户端的下行 Offer (包含新轨道的通知)
                        if (downPC && data.sdp) {
                            // SFU 通常在 DownPC 上聚合所有发布者的轨道
                            await handleDownOffer(data.sdp); 
                        }
                        break;
                    case 'down_candidate':
                        if (downPC && data.candidate) {
                            downPC.addIceCandidate(data.candidate).catch(e => console.error("Error adding down_candidate:", e));
                        }
                        break;
                        
                    case 'user_left':
                        const leavingUID = data.uid;
                        const videoElement = remoteVideoElements[leavingUID];
                        if (videoElement) {
                            videoElement.remove();
                            delete remoteVideoElements[leavingUID];
                            updateStatus(`用户 ${leavingUID} 已离开房间。`);
                        }
                        break;
                        
                    case 'user_joined':
                        updateStatus(`新用户 ${data.uid} 加入房间。`);
                        // 实际媒体流会在 down_offer 后开始接收
                        break;

                    default:
                        console.warn('Unknown signal event:', signalEvent, data);
                }
            };

            ws.onclose = () => {
                updateStatus('WebSocket 连接断开');
                cleanup();
            };

            ws.onerror = (error) => {
                updateStatus('WebSocket 错误，请检查服务器地址和运行状态');
                console.error('WebSocket Error:', error);
            };
        }

        // ------------------- 媒体和 PC 创建 -------------------

        async function startLocalMedia() {
            try {
                localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                document.getElementById('localVideo').srcObject = localStream;
            } catch (error) {
                updateStatus('媒体权限被拒绝或设备不可用');
                console.error('Error accessing media devices:', error);
                throw error;
            }
        }

        /**
         * 创建上行 PeerConnection (用于发送本地媒体到 SFU)
         * @param {MediaStream} stream 
         */
        async function createUpPC(stream) {
            upPC = new RTCPeerConnection(CONFIG);
            
            // 1. 添加本地轨道
            stream.getTracks().forEach(track => {
                upPC.addTrack(track, stream);
            });

            // 2. 监听 ICE 候选，并发送给服务器 (事件: up_candidate)
            upPC.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal('up_candidate', { candidate: event.candidate.toJSON() });
                }
            };
            
            // 3. 创建 Offer
            const offer = await upPC.createOffer();
            await upPC.setLocalDescription(offer);
            
            // 4. 发送 Offer 给服务器 (事件: up_offer)
            sendSignal('up_offer', { 
                uid: localUID, // 使用服务器分配的 UID
                sdp: upPC.localDescription.sdp 
            });
            updateStatus('已发送上行 Offer...');
        }
        
        /**
         * 确保 DownPC 存在 (用于接收 SFU 转发的媒体)
         */
        async function ensureDownPC() {
            if (downPC) {
                return;
            }
            
            downPC = new RTCPeerConnection(CONFIG);
            
            // 1. 监听 ICE 候选，并发送给服务器 (事件: down_candidate)
            downPC.onicecandidate = (event) => {
                if (event.candidate) {
                    sendSignal('down_candidate', { candidate: event.candidate.toJSON() });
                }
            };

            // 2. 监听远端轨道
            downPC.ontrack = (event) => {
                const track = event.track;
                const stream = event.streams[0];
                
                // ⚠️ 假设 SFU 通过某种方式（例如 SDP 或 stream.id）将发布者 UID 与轨道关联
                // 在简单的 SFU 实现中，有时会将发布者的 UID 嵌入到 stream.id 中。
                // 推荐的做法是 SFU 发送包含元数据的信令。这里暂用 stream.id 作为 UID。
                const publisherUID = stream.id || track.id; 

                if (!publisherUID || publisherUID === localUID) {
                    console.warn("ontrack: 无法识别发布者 UID 或为本地流");
                    return;
                }

                // 查找或创建视频元素
                let videoDiv = remoteVideoElements[publisherUID];
                if (!videoDiv) {
                    updateStatus(`收到来自 ${publisherUID} 的媒体轨道`);
                    
                    // 动态创建远端视频元素
                    videoDiv = document.createElement('div');
                    videoDiv.className = 'video-container';
                    videoDiv.id = `video-${publisherUID}`;
                    videoDiv.innerHTML = `<h2>远端视频 (${publisherUID})</h2>`;
                    
                    const video = document.createElement('video');
                    video.autoplay = true;
                    video.playsInline = true;
                    video.srcObject = stream;
                    
                    videoDiv.appendChild(video);
                    document.getElementById('videos').appendChild(videoDiv);
                    
                    remoteVideoElements[publisherUID] = videoDiv;
                }

                // 监听 stream 移除事件
                stream.onremovetrack = () => {
                    if (stream.getTracks().length === 0) {
                        // 在 SFU 聚合模式下，通常只有整个 DownPC 关闭时才会触发，
                        // 但这是一个标准的清理机制。
                        const elementToRemove = remoteVideoElements[publisherUID];
                        if(elementToRemove) {
                            elementToRemove.remove();
                            delete remoteVideoElements[publisherUID];
                            updateStatus(`远端 ${publisherUID} 的流已移除`);
                        }
                    }
                };
            };
        }
        
        /**
         * 处理 SFU 发来的 Down Offer
         * @param {string} sdp 
         */
        async function handleDownOffer(sdp) {
            updateStatus(`收到来自 SFU 的 Down Offer...`);
            
            await downPC.setRemoteDescription({ type: 'offer', sdp });
            const answer = await downPC.createAnswer();
            await downPC.setLocalDescription(answer);

            // 发送 Answer 给服务器 (事件: down_answer)
            sendSignal('down_answer', {
                sdp: downPC.localDescription.sdp,
                // 不需要 from 字段，因为它是针对整个 DownPC
            });
            updateStatus('已发送 Down Answer...');
        }


        // ------------------- 房间控制 -------------------

        function joinRoom() {
            const roomID = document.getElementById('roomIdInput').value.trim();
            if (roomID) {
                // 清理旧连接，防止重复创建
                cleanup(); 
                setupWebSocket(roomID);
            } else {
                alert('请输入房间号！');
            }
        }

        // ------------------- 辅助函数和清理 -------------------

        function sendSignal(event, data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = { event, data };
                ws.send(JSON.stringify(message));
            }
        }

        function cleanup() {
            // 1. 清理本地媒体
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                document.getElementById('localVideo').srcObject = null;
                localStream = null;
            }
            
            // 2. 关闭 PC
            if (upPC) {
                upPC.close();
                upPC = null;
            }
            if (downPC) {
                downPC.close();
                downPC = null;
            }
            
            // 3. 关闭 WebSocket
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // 4. 移除远端视频
            Object.values(remoteVideoElements).forEach(el => el.remove());
            remoteVideoElements = {};
            
            // 5. 重置状态
            localUID = null;
            localUidDisplay.textContent = '---';
            updateStatus('已清理并断开连接');
        }

        // 页面加载时清理一次（防止浏览器缓存旧状态）
        cleanup();
        window.addEventListener('beforeunload', cleanup);
    </script>

</body>
</html>